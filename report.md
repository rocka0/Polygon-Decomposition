# <center>CSF364: Design and Analysis of Algorithms</center>
### <center>Assignment 1: Decomposition of simple polygons into convex polygons</center>
#### <center>Ashwin Arun (2020A7PS1291H)</center>
#### <center>Kavyanjali Agnihotri (2020A7PS0185H)</center>
#### <center>Tushar Brijesh Chenan (2020A7PS0253H)</center>

## Introduction

In this assignment, we were required to implement the research paper: [Algorithms for the decomposition of a polygon into convex polygons](https://doi.org/10.1016/S0377-2217%2899%2900033-8)

The paper primarily focuses on $2$ objectives:

1. Decomposing a given simple polygon into several non-overlapping convex polygons without the addition of any extra vertices.
2. Merging two or more convex polygons of the planar subdivision obtained above so as to reduce the number of convex polygons in the decomposition.

Our additional tasks were as follows:

1. Store the planar subdivision in a structure known as a [DCEL](https://en.wikipedia.org/wiki/Doubly_connected_edge_list) which allows us to effectively represent and query planar subdivisions.
2. Write a program to visualize the output of the algorithm, i.e, given a simple polygon, output the decomposition produced by the algorithm in a visually intuitive way.

## DCEL: The What and The How

Explain DCEL here

## Plotting the outputs

`plot.py` takes the following as **input files**:

- `input.txt`: First line is the number of coordinates in the original polygon followed by its coordinates in clockwise order.
- `before.txt`: First line is the number of polygons generated by the decomposition process. The next lines have the number of coordinates in decomposed polygons followed by their coordinates in clockwise order.
- `after.txt`: First line is the number of polygons after the merging process. The next lines have the number of coordinates in merged polygon followed by their coordinates in clockwise order.

It generates **three** plots as follows:

- `polygon.png`: Plot generated for the original polygon in `input.txt`.
- `before.png`: Plot generated for the decomposed polygons in `before.txt`.
- `after.png`: Plot generated for the merged polygons in `after.txt`. 

### Working:

1. For each input file, the coordinates are converted to floating points and extracted into a list. The starting coordinate is appended to the end of the list to close the polygon.

2. The code plots a simple scatter plot with lines between the consecutive points for the polygon in `input.txt`. The points are colored red.

3. The code plots each decomposition in `before.txt` using the plot function of Matplotlib. These decomposition are filled with a color (among 10 colors) using fill. The points of the original polygon are plotted(in red) using scatter plot on top of these decompositions.

4. Plot is generated for `after.txt` in a similar manner.

## Writing a simple polygon generator

`gen.py` is the script we are using to generate polygons of arbitrary size. The python script uses the `secrets` module which is cryptographically secure which means we have a minimum amount of bias in our randomness.

We first start by generating the number of vertices of our polygon $n$. We will refer to the collection of points as $P$. We then find the leftmost and rightmost endpoints of $P$ and connect them by a line called $l$. Line $l$ divides $P$ into $2$ sets - $U$ and $L$. $U$ is the set of points above the line $l$ and $L$ is the set of points below $l$.

We sort the points of $U$ in increasing order of $x$ coordinates and $L$ in decreasing order of $x$ coordinates. Then we concatenate $U$ with reverse list of $L$ which gives us a simple polygon.

## Findings and Analysis

 - Running time of algorithm $vs$ number of vertices ($n$) in the simple polygon.
	- For smaller $n$, do more trials and for larger $n$, do less trials 
 - Number of decompositions $vs$ number of vertices ($n$) in the simple polygon.
	- As a corollary, we also plot number of polygons reduced (merged) vs number of vertices ($n$) in the simple polygon.
 - Simple hand made test case to identify the effect of start point of algorithm on output.
 - One real life significant test case (Eg. India map as a simple polygon or anything else)

## Experimental Time Complexity
Based on the plots, we can see that the program runs in $$ \mathcal{O}(n^{2} \log n) $$
